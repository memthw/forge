package me.mthw.forge.content;

import java.awt.Component;
import java.awt.GridBagConstraints;
import java.awt.Insets;
import java.util.List;
import java.util.logging.Level;
import javax.swing.JFileChooser;

import javax.swing.JLabel;
import javax.swing.text.AbstractDocument;
import javax.swing.text.AttributeSet;
import javax.swing.text.BadLocationException;
import javax.swing.text.DocumentFilter;
import org.openide.nodes.Node;
import org.openide.util.RequestProcessor;
import org.openide.util.lookup.ServiceProvider;
import org.sleuthkit.autopsy.casemodule.Case;
import org.sleuthkit.autopsy.casemodule.NoCurrentCaseException;
import org.sleuthkit.autopsy.corecomponentinterfaces.DataContentViewer;
import org.sleuthkit.autopsy.coreutils.Logger;
import org.sleuthkit.autopsy.coreutils.MessageNotifyUtil;
import org.sleuthkit.autopsy.ingest.IngestServices;
import org.sleuthkit.datamodel.AbstractFile;
import org.sleuthkit.datamodel.BlackboardArtifact;
import org.sleuthkit.datamodel.BlackboardAttribute;
import org.sleuthkit.datamodel.TskCoreException;
import org.sleuthkit.datamodel.blackboardutils.attributes.BlackboardJsonAttrUtil;
import org.sleuthkit.datamodel.blackboardutils.attributes.BlackboardJsonAttrUtil.InvalidJsonException;

import me.mthw.forge.CrackerOptions;
import me.mthw.forge.cracker.CrackerControl;
import me.mthw.forge.ingest.ForgeIngestFactory;
import me.mthw.forge.ingest.analyzer.volume.VolumeAnalyzerBitlocker.BitlockerKey;
import me.mthw.forge.ingest.analyzer.volume.VolumeAnalyzerBitlocker.BitlockerKeys;

@SuppressWarnings("PMD.SingularField") // UI widgets cause lots of false positives
@ServiceProvider(service = DataContentViewer.class)
public class ForgeContentViewer extends javax.swing.JPanel implements DataContentViewer
{

    private BlackboardAttribute.Type mainForgeFlagType;
    private AbstractFile selectedFile;
    private AbstractFile rootFile;
    private Logger logger;

    public ForgeContentViewer()
    {
        try
        {
            mainForgeFlagType = Case.getCurrentCaseThrows().getSleuthkitCase().getBlackboard().getAttributeType("FORGE");
        }
        catch (TskCoreException | NoCurrentCaseException e)
        {
            MessageNotifyUtil.Notify.error(": Error initializing FORGE Content Viewer", e.getMessage());
            return;
        }
        initComponents();
        jPanelCommon.setEnabled(false);
        jPanelCommon.setVisible(false);
        jPanelZipFile.setVisible(false);
        jScrollPaneZipFile.setVisible(false);
        jLabelCommonName.setText("");
        jLabelZipFileName.setText("");
        jTextFieldSymbols.setEditable(false);
        jButtonTask.setEnabled(false);
        jButton1.setEnabled(jCheckBoxWordList.isSelected());

        jCheckBoxDecrypt.setSelected(true);

        logger = IngestServices.getInstance().getLogger(ForgeIngestFactory.getModuleName());

        jTextFieldThreads.setText(Integer.toString(Runtime.getRuntime().availableProcessors()));
        ((AbstractDocument) jTextFieldRandomMin.getDocument()).setDocumentFilter(numericFilter);
        ((AbstractDocument) jTextFieldRandomMax.getDocument()).setDocumentFilter(numericFilter);
        ((AbstractDocument) jTextFieldThreads.getDocument()).setDocumentFilter(numericFilter);

    }

    /**
     * This method is called from within the constructor to initialize the form. WARNING: Do NOT modify this code. The content of this method is always regenerated by the
     * Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated
    // <editor-fold defaultstate="collapsed" desc="Generated
    // <editor-fold defaultstate="collapsed" desc="Generated
    // <editor-fold defaultstate="collapsed" desc="Generated
    // <editor-fold defaultstate="collapsed" desc="Generated
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents()
    {

        jFileChooser1 = new javax.swing.JFileChooser();
        jScrollPaneCommon = new javax.swing.JScrollPane();
        jPanelCommon = new javax.swing.JPanel();
        jScrollPaneCommonAttributes = new javax.swing.JScrollPane();
        jPanelCommonAttributes = new javax.swing.JPanel();
        jScrollPaneZipFile = new javax.swing.JScrollPane();
        jPanelZipFile = new javax.swing.JPanel();
        jButtonTask = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jCheckBoxCommon = new javax.swing.JCheckBox();
        jComboBoxCommon = new javax.swing.JComboBox<>();
        jCheckBoxStrings = new javax.swing.JCheckBox();
        jComboBoxStrings = new javax.swing.JComboBox<>();
        jLabel3 = new javax.swing.JLabel();
        jCheckBoxDigits = new javax.swing.JCheckBox();
        jCheckBoxLCase = new javax.swing.JCheckBox();
        jCheckBoxDecrypt = new javax.swing.JCheckBox();
        jLabelCommonName = new javax.swing.JLabel();
        jLabelZipFileName = new javax.swing.JLabel();
        jCheckBoxUCase = new javax.swing.JCheckBox();
        jCheckBoxSymbols = new javax.swing.JCheckBox();
        jTextFieldSymbols = new javax.swing.JTextField();
        jTextFieldRandomMin = new javax.swing.JTextField();
        jLabel5 = new javax.swing.JLabel();
        jLabel6 = new javax.swing.JLabel();
        jTextFieldRandomMax = new javax.swing.JTextField();
        jTextFieldThreads = new javax.swing.JTextField();
        jLabel4 = new javax.swing.JLabel();
        jCheckBoxTag = new javax.swing.JCheckBox();
        jCheckBoxWordList = new javax.swing.JCheckBox();
        jLabelWordlistPath = new javax.swing.JLabel();
        jButton1 = new javax.swing.JButton();

        setMinimumSize(new java.awt.Dimension(1000, 350));
        setName("ZIP"); // NOI18N
        setPreferredSize(new java.awt.Dimension(1446, 350));

        jScrollPaneCommon.setPreferredSize(new java.awt.Dimension(0, 0));

        jPanelCommon.setEnabled(false);
        jPanelCommon.setMinimumSize(new java.awt.Dimension(0, 520));

        jPanelCommonAttributes.setLayout(new java.awt.GridBagLayout());
        jScrollPaneCommonAttributes.setViewportView(jPanelCommonAttributes);

        jPanelZipFile.setLayout(new java.awt.GridBagLayout());
        jScrollPaneZipFile.setViewportView(jPanelZipFile);

        org.openide.awt.Mnemonics.setLocalizedText(jButtonTask, org.openide.util.NbBundle.getMessage(ForgeContentViewer.class, "ForgeContentViewer.jButtonTask.text")); // NOI18N
        jButtonTask.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                jButtonTaskActionPerformed(evt);
            }
        });

        jLabel1.setFont(new java.awt.Font("Noto Sans", 0, 24)); // NOI18N
        org.openide.awt.Mnemonics.setLocalizedText(jLabel1, org.openide.util.NbBundle.getMessage(ForgeContentViewer.class, "ForgeContentViewer.jLabel1.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(jLabel2, org.openide.util.NbBundle.getMessage(ForgeContentViewer.class, "ForgeContentViewer.jLabel2.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(jCheckBoxCommon, org.openide.util.NbBundle.getMessage(ForgeContentViewer.class, "ForgeContentViewer.jCheckBoxCommon.text")); // NOI18N
        jCheckBoxCommon.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                jCheckBoxCommonActionPerformed(evt);
            }
        });

        jComboBoxCommon.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "100", "500", "1 000", "10 000", "100 000", "1 000 000" }));
        jComboBoxCommon.setEnabled(false);

        org.openide.awt.Mnemonics.setLocalizedText(jCheckBoxStrings, org.openide.util.NbBundle.getMessage(ForgeContentViewer.class, "ForgeContentViewer.jCheckBoxStrings.text")); // NOI18N
        jCheckBoxStrings.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                jCheckBoxStringsActionPerformed(evt);
            }
        });

        jComboBoxStrings.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "All", "Hostname", "Data Source", "Folder" }));
        jComboBoxStrings.setEnabled(false);

        org.openide.awt.Mnemonics.setLocalizedText(jLabel3, org.openide.util.NbBundle.getMessage(ForgeContentViewer.class, "ForgeContentViewer.jLabel3.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(jCheckBoxDigits, org.openide.util.NbBundle.getMessage(ForgeContentViewer.class, "ForgeContentViewer.jCheckBoxDigits.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(jCheckBoxLCase, org.openide.util.NbBundle.getMessage(ForgeContentViewer.class, "ForgeContentViewer.jCheckBoxLCase.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(jCheckBoxDecrypt, org.openide.util.NbBundle.getMessage(ForgeContentViewer.class, "ForgeContentViewer.jCheckBoxDecrypt.text")); // NOI18N

        jLabelCommonName.setFont(new java.awt.Font("Noto Sans", 1, 24)); // NOI18N
        org.openide.awt.Mnemonics.setLocalizedText(jLabelCommonName, org.openide.util.NbBundle.getMessage(ForgeContentViewer.class, "ForgeContentViewer.jLabelCommonName.text")); // NOI18N

        jLabelZipFileName.setFont(new java.awt.Font("Noto Sans", 1, 24)); // NOI18N
        org.openide.awt.Mnemonics.setLocalizedText(jLabelZipFileName, org.openide.util.NbBundle.getMessage(ForgeContentViewer.class, "ForgeContentViewer.jLabelZipFileName.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(jCheckBoxUCase, org.openide.util.NbBundle.getMessage(ForgeContentViewer.class, "ForgeContentViewer.jCheckBoxUCase.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(jCheckBoxSymbols, org.openide.util.NbBundle.getMessage(ForgeContentViewer.class, "ForgeContentViewer.jCheckBoxSymbols.text")); // NOI18N
        jCheckBoxSymbols.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                jCheckBoxSymbolsActionPerformed(evt);
            }
        });

        jTextFieldSymbols.setText(org.openide.util.NbBundle.getMessage(ForgeContentViewer.class, "ForgeContentViewer.jTextFieldSymbols.text")); // NOI18N

        jTextFieldRandomMin.setText(org.openide.util.NbBundle.getMessage(ForgeContentViewer.class, "ForgeContentViewer.jTextFieldRandomMin.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(jLabel5, org.openide.util.NbBundle.getMessage(ForgeContentViewer.class, "ForgeContentViewer.jLabel5.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(jLabel6, org.openide.util.NbBundle.getMessage(ForgeContentViewer.class, "ForgeContentViewer.jLabel6.text")); // NOI18N

        jTextFieldRandomMax.setText(org.openide.util.NbBundle.getMessage(ForgeContentViewer.class, "ForgeContentViewer.jTextFieldRandomMax.text")); // NOI18N
        jTextFieldRandomMax.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                jTextFieldRandomMaxActionPerformed(evt);
            }
        });

        jTextFieldThreads.setText(org.openide.util.NbBundle.getMessage(ForgeContentViewer.class, "ForgeContentViewer.jTextFieldThreads.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(jLabel4, org.openide.util.NbBundle.getMessage(ForgeContentViewer.class, "ForgeContentViewer.jLabel4.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(jCheckBoxTag, org.openide.util.NbBundle.getMessage(ForgeContentViewer.class, "ForgeContentViewer.jCheckBoxTag.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(jCheckBoxWordList, org.openide.util.NbBundle.getMessage(ForgeContentViewer.class, "ForgeContentViewer.jCheckBoxWordList.text")); // NOI18N
        jCheckBoxWordList.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                jCheckBoxWordListActionPerformed(evt);
            }
        });

        jLabelWordlistPath.setFont(new java.awt.Font("Noto Sans", 0, 10)); // NOI18N
        org.openide.awt.Mnemonics.setLocalizedText(jLabelWordlistPath, org.openide.util.NbBundle.getMessage(ForgeContentViewer.class, "ForgeContentViewer.jLabelWordlistPath.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(jButton1, org.openide.util.NbBundle.getMessage(ForgeContentViewer.class, "ForgeContentViewer.jButton1.text")); // NOI18N
        jButton1.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                jButton1ActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanelCommonLayout = new javax.swing.GroupLayout(jPanelCommon);
        jPanelCommon.setLayout(jPanelCommonLayout);
        jPanelCommonLayout.setHorizontalGroup(
            jPanelCommonLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelCommonLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanelCommonLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPaneCommonAttributes, javax.swing.GroupLayout.PREFERRED_SIZE, 420, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabelCommonName))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanelCommonLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabelZipFileName)
                    .addComponent(jScrollPaneZipFile, javax.swing.GroupLayout.PREFERRED_SIZE, 420, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGroup(jPanelCommonLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelCommonLayout.createSequentialGroup()
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jPanelCommonLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(jPanelCommonLayout.createSequentialGroup()
                                .addComponent(jButtonTask)
                                .addGap(18, 18, 18)
                                .addComponent(jLabel4)
                                .addGap(5, 5, 5)
                                .addComponent(jTextFieldThreads, javax.swing.GroupLayout.PREFERRED_SIZE, 60, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addComponent(jLabel1)
                            .addGroup(jPanelCommonLayout.createSequentialGroup()
                                .addGap(6, 6, 6)
                                .addGroup(jPanelCommonLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jLabel3)
                                    .addComponent(jLabel2)))
                            .addComponent(jCheckBoxDecrypt)
                            .addGroup(jPanelCommonLayout.createSequentialGroup()
                                .addGap(32, 32, 32)
                                .addGroup(jPanelCommonLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jCheckBoxCommon)
                                    .addComponent(jCheckBoxStrings)
                                    .addGroup(jPanelCommonLayout.createSequentialGroup()
                                        .addGap(32, 32, 32)
                                        .addGroup(jPanelCommonLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                            .addComponent(jComboBoxCommon, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addComponent(jComboBoxStrings, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))))))
                    .addGroup(jPanelCommonLayout.createSequentialGroup()
                        .addGap(46, 46, 46)
                        .addGroup(jPanelCommonLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jTextFieldSymbols, javax.swing.GroupLayout.PREFERRED_SIZE, 526, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGroup(jPanelCommonLayout.createSequentialGroup()
                                .addGap(12, 12, 12)
                                .addComponent(jLabel5)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jTextFieldRandomMin, javax.swing.GroupLayout.PREFERRED_SIZE, 60, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jLabel6)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(jTextFieldRandomMax, javax.swing.GroupLayout.PREFERRED_SIZE, 60, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(jPanelCommonLayout.createSequentialGroup()
                                .addComponent(jCheckBoxDigits)
                                .addGap(18, 18, 18)
                                .addComponent(jCheckBoxLCase)
                                .addGap(18, 18, 18)
                                .addGroup(jPanelCommonLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jCheckBoxTag)
                                    .addGroup(jPanelCommonLayout.createSequentialGroup()
                                        .addComponent(jCheckBoxUCase)
                                        .addGap(18, 18, 18)
                                        .addComponent(jCheckBoxSymbols))
                                    .addComponent(jCheckBoxWordList)
                                    .addGroup(jPanelCommonLayout.createSequentialGroup()
                                        .addGap(32, 32, 32)
                                        .addGroup(jPanelCommonLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                            .addComponent(jLabelWordlistPath, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                            .addComponent(jButton1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))))))
                .addContainerGap(79, Short.MAX_VALUE))
        );
        jPanelCommonLayout.setVerticalGroup(
            jPanelCommonLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelCommonLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanelCommonLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelCommonLayout.createSequentialGroup()
                        .addGroup(jPanelCommonLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabelCommonName)
                            .addComponent(jLabelZipFileName))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jPanelCommonLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jScrollPaneCommonAttributes)
                            .addComponent(jScrollPaneZipFile)))
                    .addGroup(jPanelCommonLayout.createSequentialGroup()
                        .addComponent(jLabel1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jLabel2)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jPanelCommonLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jCheckBoxCommon)
                            .addComponent(jCheckBoxTag))
                        .addGap(27, 27, 27)
                        .addGroup(jPanelCommonLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jComboBoxCommon, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jCheckBoxWordList))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jPanelCommonLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(jPanelCommonLayout.createSequentialGroup()
                                .addComponent(jCheckBoxStrings)
                                .addGap(12, 12, 12)
                                .addComponent(jComboBoxStrings, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(jPanelCommonLayout.createSequentialGroup()
                                .addComponent(jLabelWordlistPath, javax.swing.GroupLayout.PREFERRED_SIZE, 14, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jButton1)))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel3)
                        .addGap(18, 18, 18)
                        .addGroup(jPanelCommonLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jCheckBoxDigits)
                            .addComponent(jCheckBoxLCase)
                            .addComponent(jCheckBoxUCase)
                            .addComponent(jCheckBoxSymbols))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jTextFieldSymbols, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jPanelCommonLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jTextFieldRandomMin, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel5)
                            .addComponent(jLabel6)
                            .addComponent(jTextFieldRandomMax, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 23, Short.MAX_VALUE)
                        .addComponent(jCheckBoxDecrypt)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jPanelCommonLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jButtonTask)
                            .addComponent(jTextFieldThreads, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel4))
                        .addContainerGap())))
        );

        jScrollPaneCommon.setViewportView(jPanelCommon);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPaneCommon, javax.swing.GroupLayout.DEFAULT_SIZE, 1446, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jScrollPaneCommon, javax.swing.GroupLayout.DEFAULT_SIZE, 579, Short.MAX_VALUE)
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents

    /**
     * Handles the action event triggered when the button for choosing wordlist is clicked. Opens a file chooser dialog to allow the user to select a wordlist file. If a file
     * is selected, updates the jLabelWordlistPath with the file's absolute path and makes the label visible.
     *
     * @param evt The ActionEvent triggered by the button click.
     */
    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt)// GEN-FIRST:event_jButton1ActionPerformed
    {// GEN-HEADEREND:event_jButton1ActionPerformed
        JFileChooser fileChooser = new JFileChooser();
        fileChooser.setDialogTitle("Select a wordlist file");
        fileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
        int returnValue = fileChooser.showOpenDialog(this);
        if (returnValue == JFileChooser.APPROVE_OPTION)
        {
            jLabelWordlistPath.setText(fileChooser.getSelectedFile().getAbsolutePath());
            jLabelWordlistPath.setToolTipText(fileChooser.getSelectedFile().getAbsolutePath());
            jLabelWordlistPath.setVisible(true);
        }
    }// GEN-LAST:event_jButton1ActionPerformed

    private void jCheckBoxWordListActionPerformed(java.awt.event.ActionEvent evt)// GEN-FIRST:event_jCheckBox1ActionPerformed
    {// GEN-HEADEREND:event_jCheckBox1ActionPerformed
        if (jCheckBoxWordList.isSelected())
        {
            jButton1.setEnabled(true);
        }
        else
        {
            jButton1.setEnabled(false);
            jLabelWordlistPath.setText("");
        }
    }// GEN-LAST:event_jCheckBox1ActionPerformed

    private void jCheckBoxCommonActionPerformed(java.awt.event.ActionEvent evt)// GEN-FIRST:event_jCheckBoxCommonActionPerformed
    {// GEN-HEADEREND:event_jCheckBoxCommonActionPerformed
        jComboBoxCommon.setEnabled(jCheckBoxCommon.isSelected());
    }// GEN-LAST:event_jCheckBoxCommonActionPerformed

    private void jCheckBoxStringsActionPerformed(java.awt.event.ActionEvent evt)// GEN-FIRST:event_jCheckBoxStringsActionPerformed
    {// GEN-HEADEREND:event_jCheckBoxStringsActionPerformed
        jComboBoxStrings.setEnabled(jCheckBoxStrings.isSelected());
    }// GEN-LAST:event_jCheckBoxStringsActionPerformed

    private void jCheckBoxSymbolsActionPerformed(java.awt.event.ActionEvent evt)// GEN-FIRST:event_jCheckBoxSymbolsActionPerformed
    {// GEN-HEADEREND:event_jCheckBoxSymbolsActionPerformed
        jTextFieldSymbols.setEditable(jCheckBoxSymbols.isSelected());
    }// GEN-LAST:event_jCheckBoxSymbolsActionPerformed

    private void jTextFieldRandomMaxActionPerformed(java.awt.event.ActionEvent evt)// GEN-FIRST:event_jTextFieldRandomMaxActionPerformed
    {// GEN-HEADEREND:event_jTextFieldRandomMaxActionPerformed

    }// GEN-LAST:event_jTextFieldRandomMaxActionPerformed

    /**
     * Handles the action event triggered by the jButtonTask button. This method initializes a RequestProcessor to execute a CrackerControl task asynchronously. The
     * CrackerControl is configured with the selected file, root file, the current case's Sleuthkit blackboard, and cracker options.
     *
     * @param evt The ActionEvent triggered by the button click.
     */
    private void jButtonTaskActionPerformed(java.awt.event.ActionEvent evt)// GEN-FIRST:event_jButtonTaskActionPerformed
    {// GEN-HEADEREND:event_jButtonTaskActionPerformed

        RequestProcessor rp = new RequestProcessor("FORGE Cracker", 1, true);
        CrackerControl crackerControl = new CrackerControl(selectedFile, rootFile, Case.getCurrentCase().getSleuthkitCase().getBlackboard(), createCrackerOptions());
        rp.post(crackerControl);

    }// GEN-LAST:event_jButtonTaskActionPerformed

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButtonTask;
    private javax.swing.JCheckBox jCheckBoxCommon;
    private javax.swing.JCheckBox jCheckBoxDecrypt;
    private javax.swing.JCheckBox jCheckBoxDigits;
    private javax.swing.JCheckBox jCheckBoxLCase;
    private javax.swing.JCheckBox jCheckBoxStrings;
    private javax.swing.JCheckBox jCheckBoxSymbols;
    private javax.swing.JCheckBox jCheckBoxTag;
    private javax.swing.JCheckBox jCheckBoxUCase;
    private javax.swing.JCheckBox jCheckBoxWordList;
    private javax.swing.JComboBox<String> jComboBoxCommon;
    private javax.swing.JComboBox<String> jComboBoxStrings;
    private javax.swing.JFileChooser jFileChooser1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabelCommonName;
    private javax.swing.JLabel jLabelWordlistPath;
    private javax.swing.JLabel jLabelZipFileName;
    private javax.swing.JPanel jPanelCommon;
    private javax.swing.JPanel jPanelCommonAttributes;
    private javax.swing.JPanel jPanelZipFile;
    private javax.swing.JScrollPane jScrollPaneCommon;
    private javax.swing.JScrollPane jScrollPaneCommonAttributes;
    private javax.swing.JScrollPane jScrollPaneZipFile;
    private javax.swing.JTextField jTextFieldRandomMax;
    private javax.swing.JTextField jTextFieldRandomMin;
    private javax.swing.JTextField jTextFieldSymbols;
    private javax.swing.JTextField jTextFieldThreads;
    // End of variables declaration//GEN-END:variables

    /**
     * Sets the selected node and processes its associated artifacts to determine the appropriate content to display. Enables or disables UI components based on the type of
     * artifact found.
     *
     * @param selectedNode The node selected by the user, which contains a lookup for an AbstractFile and its associated artifacts.
     * 
     */
    @Override
    public void setNode(Node selectedNode)
    {
        selectedFile = selectedNode.getLookup().lookup(AbstractFile.class);
        BlackboardArtifact forgeArtifact = null;
        try
        {
            List<BlackboardArtifact> artifacts = selectedFile.getAllArtifacts();

            for (BlackboardArtifact artifact : artifacts)
            {
                String typestr = artifact.getType().getTypeName();
                if (typestr.equals("FORGE_ZIP") || typestr.equals("FORGE_ZIP_FILE") || typestr.equals("FORGE_PDF") || typestr.equals("FORGE_OFFICE") || typestr.equals("FORGE_VOLUME_BITLOCKER") || typestr.equals("FORGE_VOLUME_LUKS"))
                {
                    forgeArtifact = artifact;
                    break;
                }
            }

            if (forgeArtifact == null)
                return;

            // Enable cracker
            if (forgeArtifact.getType().getTypeName().equals("FORGE_ZIP_FILE") || forgeArtifact.getType().getTypeName().equals("FORGE_PDF") || forgeArtifact.getType().getTypeName().equals("FORGE_OFFICE"))
                jButtonTask.setEnabled(true);

            // If file inside ZIP show details of the ZIP archive as well
            if (forgeArtifact.getType().getTypeName().equals("FORGE_ZIP_FILE"))
            {
                displayZipFile(forgeArtifact, selectedNode, selectedFile.getName());
                jPanelZipFile.setVisible(true);
                jScrollPaneZipFile.setVisible(true);
            }
            else
                displayCommonContent(forgeArtifact, selectedFile.getName());
            jPanelCommon.setEnabled(true);
            jPanelCommon.setVisible(true);
        }
        catch (TskCoreException e)
        {
            MessageNotifyUtil.Notify.error(getName() + ": Cryptographic library exeption", e.getMessage());
            logger.log(Level.WARNING, "Cryptographic library exception", e.getMessage());
            return;
        }

    }

    @Override
    public String getTitle()
    {
        return "FORGE";
    }

    @Override
    public String getToolTip()
    {
        return "FORGE Content Viewer";
    }

    @Override
    public DataContentViewer createInstance()
    {
        return new ForgeContentViewer();
    }

    @Override
    public Component getComponent()
    {
        // we can do this because this class extends JPanel
        return this;
    }

    @Override
    public void resetComponent()
    {
        jPanelCommon.setEnabled(false);
        jPanelCommon.setVisible(false);

        jPanelCommonAttributes.removeAll();
        jPanelZipFile.removeAll();
        jPanelZipFile.setVisible(false);
        jScrollPaneZipFile.setVisible(false);

        jButtonTask.setEnabled(false);

        jLabelCommonName.setText("");
        jLabelZipFileName.setText("");
        selectedFile = null;
        rootFile = null;
    }

    /**
     * Determines if the given node is supported by checking for the presence
     * of a specific blackboard attribute ("FORGE") in the associated file's
     * general information artifact.
     *
     * @param node The node to check for support.
     * @return {@code true} if the node is supported (i.e., the "FORGE" attribute
     *         exists in the file's general information artifact), {@code false} otherwise.
     * Logs the error and returns {@code false} in case of exceptions.
     */
    @Override
    public boolean isSupported(Node node)
    {
        AbstractFile content = node.getLookup().lookup(AbstractFile.class);

        try
        {
            if (mainForgeFlagType == null)
                mainForgeFlagType = Case.getCurrentCaseThrows().getSleuthkitCase().getBlackboard().getAttributeType("FORGE");
            BlackboardAttribute attribute = content.getGenInfoArtifact().getAttribute(mainForgeFlagType);
            return attribute != null;
        }
        catch (TskCoreException | NoCurrentCaseException e)
        {
            MessageNotifyUtil.Notify.error(getName() + ": Error getting file information", e.getMessage());
            logger.log(Level.WARNING, "Error getting file information", e.getMessage());
            return false;
        }
    }

    /**
     * Determines the preference level for handling a given node.
     * 
     * @param node The node to evaluate.
     * @return An integer representing the preference level. Higher values indicate
     *         a stronger preference. This implementation always returns 8.
     */
    @Override
    public int isPreferred(Node node)
    {
        return 8;
    }

    /**
     * Displays the contents of a ZIP archive associated with a given artifact.
     * This method retrieves attributes from the provided artifact and displays
     * them in a panel. It also fetches the root file and associated artifact
     * for the ZIP file and displays common content information.
     *
     * @param forgeArtifact The artifact representing the ZIP file.
     * @param selectedNode  The selected node in the UI (not directly used in this method).
     * @param fileName      The name of the ZIP file to display.
     */
    private void displayZipFile(BlackboardArtifact forgeArtifact, Node selectedNode, String fileName)
    {
        jLabelZipFileName.setText(fileName);
        List<BlackboardAttribute> attributes;
        try
        {
            attributes = forgeArtifact.getAttributes();
        }
        catch (TskCoreException e)
        {
            MessageNotifyUtil.Notify.error(getName() + ": Error getting file information", e.getMessage());
            logger.log(Level.WARNING, "Error getting file information", e.getMessage());
            return;
        }

        GridBagConstraints gbc = new GridBagConstraints();
        gbc.insets = new Insets(5, 5, 5, 15);
        gbc.anchor = GridBagConstraints.WEST;

        int row = 0;
        for (BlackboardAttribute attribute : attributes)
        {
            gbc.gridx = 0;
            gbc.gridy = row;
            jPanelZipFile.add(new JLabel(attribute.getAttributeType().getDisplayName() + ":"), gbc); // Label
            gbc.gridx = 1;
            jPanelZipFile.add(new JLabel(attribute.getDisplayString()), gbc); // Value

            row++;
        }

        jPanelZipFile.revalidate(); // Refresh UI
        jPanelZipFile.repaint();
        long rootID;
        BlackboardArtifact archiveArtifact;
        try
        {
            BlackboardAttribute.Type art = Case.getCurrentCaseThrows().getSleuthkitCase().getBlackboard().getAttributeType("FORGE_ZIP_FILE_ROOT_ID");
            rootID = forgeArtifact.getAttribute(art).getValueLong();

            rootFile = Case.getCurrentCase().getSleuthkitCase().getAbstractFileById(rootID);
            archiveArtifact = rootFile.getArtifacts("FORGE_ZIP").get(0);
        }
        catch (TskCoreException | NoCurrentCaseException e)
        {
            MessageNotifyUtil.Notify.error(getName() + ": Error getting file information", e.getMessage());
            logger.log(Level.WARNING, "Error getting file information", e.getMessage());
            return;
        }

        displayCommonContent(archiveArtifact, rootFile.getName());

    }

    /**
     * Displays common content attributes of a given BlackboardArtifact in the UI.
     * 
     * @param forgeArtifact The BlackboardArtifact containing the attributes to display.
     * @param fileName      The name of the file associated with the artifact, used to set the label.
     * 
     * This method retrieves the attributes of the provided artifact and displays them
     * in a JPanel using a GridBagLayout. If the artifact contains a specific attribute
     * type "FORGE_BITLOCKER_KEY", it parses the JSON content of the attribute to extract
     * Bitlocker keys and displays their details (GUID and protection type). For all other
     * attributes, it displays their type and value.
     * 
     * The method handles exceptions such as TskCoreException when retrieving attributes
     * and InvalidJsonException when parsing JSON content, ensuring the UI remains responsive.
     * After adding the attributes to the panel, it refreshes the UI to reflect the changes.
     */
    private void displayCommonContent(BlackboardArtifact forgeArtifact, String fileName)
    {
        jLabelCommonName.setText(fileName);
        List<BlackboardAttribute> attributes;
        try
        {
            attributes = forgeArtifact.getAttributes();
        }
        catch (TskCoreException e)
        {
            return;
        }

        GridBagConstraints gbc = new GridBagConstraints();
        gbc.insets = new Insets(5, 5, 5, 15);
        gbc.anchor = GridBagConstraints.WEST;

        int row = 0;
        for (BlackboardAttribute attribute : attributes)
        {
            if (attribute.getAttributeType().getTypeName().equals("FORGE_BITLOCKER_KEY"))
            {
                BitlockerKeys keys;
                try
                {
                    keys = BlackboardJsonAttrUtil.fromAttribute(attribute, BitlockerKeys.class);
                }
                catch (InvalidJsonException e)
                {
                    continue;
                }

                gbc.gridx = 0;
                gbc.gridy = row;
                jPanelCommonAttributes.add(new JLabel("Keys:"), gbc); // Label
                row++;
                int keyIndex = 1;
                for (BitlockerKey key : keys.keyList)
                {
                    gbc.gridx = 0;
                    gbc.gridy = row;
                    jPanelCommonAttributes.add(new JLabel("    Key " + keyIndex + " GUID:"), gbc); // Label
                    gbc.gridx = 1;
                    jPanelCommonAttributes.add(new JLabel(key.FORGE_BITLOCKER_KEY_GUID), gbc); // Value
                    row++;

                    gbc.gridx = 0;
                    gbc.gridy = row;
                    jPanelCommonAttributes.add(new JLabel("    Key " + keyIndex + " protection:"), gbc); // Label
                    gbc.gridx = 1;
                    jPanelCommonAttributes.add(new JLabel(key.FORGE_BITLOCKER_KEY_PROTECTION_TYPE), gbc); // Value
                    row++;
                    keyIndex++;
                }
                continue;
            }
            gbc.gridx = 0;
            gbc.gridy = row;
            jPanelCommonAttributes.add(new JLabel(attribute.getAttributeType().getDisplayName() + ":"), gbc); // Label
            gbc.gridx = 1;
            jPanelCommonAttributes.add(new JLabel(attribute.getDisplayString()), gbc); // Value

            row++;
        }

        jPanelCommonAttributes.revalidate(); // Refresh UI
        jPanelCommonAttributes.repaint();
    }

    /**
     * Creates and configures a CrackerOptions object based on the current state of the UI components.
     *
     * @return A fully configured CrackerOptions object.
     *
     * The method performs the following:
     * - Sets options for common passwords based on the state of the "Common" checkbox and combo box.
     * - Configures string-related options based on the "Strings" checkbox and combo box.
     * - Determines whether to decrypt a file based on the "Decrypt File" checkbox.
     * - Builds a character set for random password generation based on selected checkboxes
     *   (lowercase, uppercase, digits, symbols) and a custom symbol input field.
     * - Configures random password generation settings, including minimum and maximum length,
     *   if a character set is specified.
     * - Sets the "Tag" option based on the corresponding checkbox.
     * - Configures wordlist file usage and its path based on the "Wordlist" checkbox and label.
     * - Sets the number of threads to use, defaulting to 1 if the input field is empty.
     */
    private CrackerOptions createCrackerOptions()
    {

        final String LOWERCASE = "abcdefghijklmnopqrstuvwxyz";
        final String UPPERCASE = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        final String DIGITS = "0123456789";

        CrackerOptions crackerOptions = new CrackerOptions();
        crackerOptions.common = jCheckBoxCommon.isSelected();
        crackerOptions.commonCount = jComboBoxCommon.getSelectedItem().toString();
        crackerOptions.strings = jCheckBoxStrings.isSelected();
        crackerOptions.stringsType = jComboBoxStrings.getSelectedItem().toString();
        crackerOptions.decryptFile = jCheckBoxDecrypt.isSelected();

        String charset = "";
        if (jCheckBoxLCase.isSelected())
            charset += LOWERCASE;
        if (jCheckBoxUCase.isSelected())
            charset += UPPERCASE;
        if (jCheckBoxDigits.isSelected())
            charset += DIGITS;
        if (jCheckBoxSymbols.isSelected())
            charset += jTextFieldSymbols.getText();

        if (charset.isEmpty() == false)
        {
            crackerOptions.randomPassword = true;
            crackerOptions.randomPasswordMinLength = jTextFieldRandomMin.getText().isEmpty() ? 1 : Integer.parseInt(jTextFieldRandomMin.getText());
            crackerOptions.randomPasswordMaxLength = jTextFieldRandomMax.getText().isEmpty() ? 5 : Integer.parseInt(jTextFieldRandomMax.getText());
            crackerOptions.randomPasswordCharSet = charset.toCharArray();
        }

        crackerOptions.tag = jCheckBoxTag.isSelected();

        crackerOptions.file = jCheckBoxWordList.isSelected();
        crackerOptions.filePath = jLabelWordlistPath.getText();
        crackerOptions.threadsCount = jTextFieldThreads.getText().isEmpty() ? 1 : Integer.parseInt(jTextFieldThreads.getText());
        return crackerOptions;

    }

    /**
     * A custom DocumentFilter implementation that allows only numeric input.
     * This filter ensures that only digits (0-9) are inserted or replaced in the textField.
     *
     * Methods:
     * - {@link #insertString(FilterBypass, int, String, AttributeSet)}:
     *   Overrides the default behavior to allow insertion of numeric strings only.
     * - {@link #replace(FilterBypass, int, int, String, AttributeSet)}:
     *   Overrides the default behavior to allow replacement with numeric strings only.
     *
     * Usage:
     * Attach this filter to a textField to restrict its input to numeric values.
     */
    DocumentFilter numericFilter = new DocumentFilter()
    {
        @Override
        public void insertString(FilterBypass fb, int offset, String string, AttributeSet attr) throws BadLocationException
        {
            if (string.matches("\\d+"))
            {
                super.insertString(fb, offset, string, attr);
            }
        }

        @Override
        public void replace(FilterBypass fb, int offset, int length, String text, AttributeSet attrs) throws BadLocationException
        {
            if (text.matches("\\d+"))
            {
                super.replace(fb, offset, length, text, attrs);
            }
        }
    };

}